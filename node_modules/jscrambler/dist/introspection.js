"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.intoObjectType = intoObjectType;
exports.mutation = mutation;
exports.query = query;
exports.type = type;
require("core-js/modules/web.dom-collections.iterator.js");
var _lodash = _interopRequireDefault(require("lodash.clonedeep"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const typeCache = {};
async function type(client, name) {
  const {
    jscramblerVersion
  } = client.options;
  if (!typeCache[jscramblerVersion]) {
    typeCache[jscramblerVersion] = {};
  }
  if (typeCache[jscramblerVersion][name]) {
    return typeCache[jscramblerVersion][name];
  }
  const query = {
    query: "\nquery getType($name: String!) {\n  __type(name: $name) {\n    kind\n    name\n    description\n    fields(includeDeprecated: true) {\n      name\n      description\n      args {\n        ...InputValue\n      }\n      type {\n        ...TypeRef\n      }\n      isDeprecated\n      deprecationReason\n    }\n    inputFields {\n      ...InputValue\n    }\n    interfaces {\n      ...TypeRef\n    }\n    enumValues(includeDeprecated: true) {\n      name\n      description\n      isDeprecated\n      deprecationReason\n    }\n    possibleTypes {\n      ...TypeRef\n    }\n  }\n}\n\nfragment InputValue on __InputValue {\n  name\n  description\n  type { ...TypeRef }\n  defaultValue\n}\n\nfragment TypeRef on __Type {\n  kind\n  name\n  inputFields {\n    name\n    type {\n      name\n      kind\n    }\n  }\n  ofType {\n    kind\n    name\n    ofType {\n      kind\n      name\n      ofType {\n        kind\n        name\n      }\n    }\n  }\n}",
    params: JSON.stringify({
      name
    })
  };
  const res = await client.get('/application', query);
  const __type = res.data.__type;
  typeCache[jscramblerVersion][__type.name] = __type;
  return __type;
}
async function mutation(client, name) {
  const rootMutation = await type(client, 'RootMutation');
  const mutationType = rootMutation.fields.find(f => f.name === name);
  return mutationType;
}
async function query(client, name) {
  const rootQuery = await type(client, 'RootQuery');
  const queryType = rootQuery.fields.find(f => f.name === name);
  return queryType;
}
async function intoObjectType(client, obj, name) {
  var _resultType$fields;
  const resultType = await type(client, name);
  const fields = (_resultType$fields = resultType.fields) !== null && _resultType$fields !== void 0 ? _resultType$fields : resultType.inputFields;
  const finalObj = {};
  const keys = Object.keys(obj);
  await Promise.all(keys.map(async k => {
    const field = fields.find(f => f.name === k);
    if (field && field.type) {
      finalObj[k] = (0, _lodash.default)(obj[k]);
      if (field.type.kind === 'OBJECT' && !!field.type.name) {
        finalObj[k] = await intoObjectType(client, finalObj[k], field.type.name);
        return;
      }
      if ((field.type.kind === 'NON_NULL' || field.type.kind === 'LIST') && field.type.ofType.kind === 'OBJECT') {
        finalObj[k] = await intoObjectType(client, finalObj[k], field.type.ofType.name);
        return;
      }
      if (field.type.name === 'String' && typeof finalObj[k] !== 'string') {
        finalObj[k] = JSON.stringify(finalObj[k]);
      }
    }
  }));
  return finalObj;
}